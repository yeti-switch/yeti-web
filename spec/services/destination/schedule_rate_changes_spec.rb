# frozen_string_literal: true

RSpec.describe Destination::ScheduleRateChanges do
  subject { described_class.call(**service_params) }

  let(:service_params) do
    {
      ids:,
      apply_time:,
      initial_interval:,
      initial_rate:,
      next_interval:,
      next_rate:,
      connect_fee:
    }
  end

  let!(:destinations) do
    [
      FactoryBot.create(:destination, destination1_attrs),
      FactoryBot.create(:destination, destination2_attrs),
      FactoryBot.create(:destination, destination3_attrs)
    ]
  end
  let(:destination1_attrs) { { valid_till: apply_time + 1.month } }
  let(:destination2_attrs) { { valid_till: apply_time + 1.day } }
  let(:destination3_attrs) { { valid_till: apply_time + 1.second } }

  let(:ids) { destinations.pluck(:id) }
  let(:apply_time) { 1.month.from_now.to_date }
  let(:initial_interval) { 65 }
  let(:initial_rate) { 0.1 }
  let(:next_interval) { 55 }
  let(:next_rate) { 0.2 }
  let(:connect_fee) { 0.03 }

  before do
    # not affected destinations
    FactoryBot.create_list(:destination, 3)
  end

  it 'should create DestinationNextRate for destinations' do
    # reload need cause uuid is generated by db
    destinations_attributes = destinations.map { |destination| destination.reload.attributes }

    expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

    destinations.each(&:reload)
    expect(destinations.map(&:attributes)).to eq(destinations_attributes)

    destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
    expect(destination_next_rates).not_to be_empty
    destination_next_rates.each_with_index do |d_next_rate, index|
      destination = destinations[index]

      expect(d_next_rate).to have_attributes(
                               initial_interval:,
                               initial_rate:,
                               next_interval:,
                               next_rate:,
                               connect_fee:,
                               apply_time:,
                               destination_id: destination.id
                             )
    end
  end

  context 'when destinations already have destinations next rates' do
    let!(:destination_next_rates) do
      [
        *FactoryBot.create_list(:destination_next_rate, 3, destination: destinations[0]),
        FactoryBot.create(:destination_next_rate, destination: destinations[1])
      ]
    end

    before do
      # not affected destinations
      FactoryBot.create_list(:destination_next_rate, 3)
    end

    it 'should delete old DestinationNextRate for destinations' do
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size - destination_next_rates.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate:,
                                 next_interval:,
                                 next_rate:,
                                 connect_fee:,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when destinations have valid_till >= apply_time' do
    let(:destination1_attrs) { super().merge(valid_till: apply_time - 1.second) }
    let(:destination2_attrs) { super().merge(valid_till: apply_time) }

    let(:new_valid_till) { apply_time + 40.years }

    it 'should update expired destinations valid_till' do
      destination1_attributes = destinations[0].reload.attributes.symbolize_keys
      destination2_attributes = destinations[1].reload.attributes.symbolize_keys
      destination3_attributes = destinations[2].reload.attributes.symbolize_keys

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      expect(destinations[0].reload).to have_attributes(
                                         **destination1_attributes,
                                         valid_till: new_valid_till
                                       )
      expect(destinations[1].reload).to have_attributes(
                                         **destination2_attributes,
                                         valid_till: new_valid_till
                                       )
      expect(destinations[2].reload).to have_attributes(**destination3_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate:,
                                 next_interval:,
                                 next_rate:,
                                 connect_fee:,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only initial_interval' do
    let(:service_params) do
      super().merge(
        initial_rate: nil,
        next_interval: nil,
        next_rate: nil,
        connect_fee: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate: destination.initial_rate,
                                 next_interval: destination.next_interval,
                                 next_rate: destination.next_rate,
                                 connect_fee: destination.connect_fee,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only initial_rate' do
    let(:service_params) do
      super().merge(
        initial_interval: nil,
        next_interval: nil,
        next_rate: nil,
        connect_fee: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval: destination.initial_interval,
                                 initial_rate:,
                                 next_interval: destination.next_interval,
                                 next_rate: destination.next_rate,
                                 connect_fee: destination.connect_fee,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only next_interval' do
    let(:service_params) do
      super().merge(
        initial_interval: nil,
        initial_rate: nil,
        next_rate: nil,
        connect_fee: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval: destination.initial_interval,
                                 initial_rate: destination.initial_rate,
                                 next_interval:,
                                 next_rate: destination.next_rate,
                                 connect_fee: destination.connect_fee,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only next_rate' do
    let(:service_params) do
      super().merge(
        initial_interval: nil,
        initial_rate: nil,
        next_interval: nil,
        connect_fee: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval: destination.initial_interval,
                                 initial_rate: destination.initial_rate,
                                 next_interval: destination.next_interval,
                                 next_rate:,
                                 connect_fee: destination.connect_fee,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only connect_fee' do
    let(:service_params) do
      super().merge(
        initial_interval: nil,
        initial_rate: nil,
        next_interval: nil,
        next_rate: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval: destination.initial_interval,
                                 initial_rate: destination.initial_rate,
                                 next_interval: destination.next_interval,
                                 next_rate: destination.next_rate,
                                 connect_fee:,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when passed only initial_interval and initial_rate' do
    let(:service_params) do
      super().merge(
        next_interval: nil,
        next_rate: nil,
        connect_fee: nil
      )
    end

    it 'should create DestinationNextRate for destinations' do
      # reload need cause uuid is generated by db
      destinations_attributes = destinations.map { |destination| destination.reload.attributes }

      expect { subject }.to change { Routing::DestinationNextRate.count }.by(destinations.size)

      destinations.each(&:reload)
      expect(destinations.map(&:attributes)).to eq(destinations_attributes)

      destination_next_rates = Routing::DestinationNextRate.last(destinations.size).sort_by(&:destination_id)
      expect(destination_next_rates).not_to be_empty
      destination_next_rates.each_with_index do |d_next_rate, index|
        destination = destinations[index]

        expect(d_next_rate).to have_attributes(
                                 initial_interval:,
                                 initial_rate:,
                                 next_interval: destination.next_interval,
                                 next_rate: destination.next_rate,
                                 connect_fee: destination.connect_fee,
                                 apply_time:,
                                 destination_id: destination.id
                               )
      end
    end
  end

  context 'when does not passed any of rate parameters' do
    let(:service_params) do
      super().merge(
        initial_interval: nil,
        initial_rate: nil,
        next_interval: nil,
        next_rate: nil,
        connect_fee: nil
      )
    end

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, 'At least one of the following parameters must be present: initial_interval, initial_rate, next_interval, next_rate, connect_fee')
    end
  end

  context 'when apply_time is nil' do
    let(:service_params) { super().merge(apply_time: nil) }

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, "Apply time can't be blank")
    end
  end

  context 'when apply_time is in the past' do
    let(:apply_time) { 1.month.ago.to_date }

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, 'Apply time must be in the future')
    end
  end

  context 'when ids=[]' do
    let(:ids) { [] }

    it 'should raise an error' do
      expect { subject }.to raise_error(described_class::Error, "Ids can't be blank")
    end
  end
end
