name: Tests
on:
  pull_request:
  push:
    branches: [ master ]

jobs:
  gems-caching:
    name: GEMs caching
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    steps:
      - uses: actions/checkout@v4
      - name: Fetching gems cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: install gems
        run: make gems-test
      - name: install gems for pgq
        run: make pgq-processors-gems
      - name: Caching gems
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}

  lint:
    name: Rubocop and bundle audit
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    needs: gems-caching
    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: Rubocop and bundle audit
        run: make lint

  database_consistency:
    name: DB consistency check
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    services:
      db:
        image: ghcr.io/yeti-switch/yeti-web/pgsql:18
    needs: gems-caching
    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: run make database_consistency
        continue-on-error: true
        run: make database_consistency
        env:
          YETI_DB_HOST: db
          YETI_DB_PORT: 5432
          CDR_DB_HOST: db
          CDR_DB_PORT: 5432

      - name: Save artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: database_consistency-artifacts
          if-no-files-found: ignore
          include-hidden-files: true
          path: |
            log/



  brakeman:
    name: Brakeman
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    needs: gems-caching
    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: brakeman
        continue-on-error: true
        run: make brakeman

  pgq-processors:
    name: PqQ processors tests
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    services:
      db:
        image: ghcr.io/yeti-switch/yeti-web/pgsql:18

    needs: gems-caching
    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: Run test-pgq-processors
        run: make test-pgq-processors
        env:
          YETI_DB_HOST: db
          YETI_DB_PORT: 5432
          CDR_DB_HOST: db
          CDR_DB_PORT: 5432

  rspec:
    name: Rspec tests
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    services:
      db:
        image: ghcr.io/yeti-switch/yeti-web/pgsql:18

    needs: gems-caching
    strategy:
      fail-fast: false
      matrix:
        # Set N number of parallel jobs you want to run tests on.
        # Use higher number if you have slow tests to split them on more parallel jobs.
        # Remember to update ci_node_index below to 0..N-1
        ci_node_total: [8]
        # set N-1 indexes for parallel jobs
        # When you run 2 parallel jobs then first job will have index 0, the second job will have index 1 etc
        ci_node_index: [0, 1, 2, 3, 4, 5, 6, 7]

    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}

      - name: Download runtime log artifact
        id: download-runtime-log
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
        with:
          script: |
            const branch = process.env.BRANCH_NAME || 'unknown';
            const artifactName = `runtime-log-${branch}`;
            const artifacts = await github.paginate(github.rest.actions.listArtifactsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const available = artifacts
              .filter(a => a.name === artifactName && !a.expired)
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            if (!available.length) {
              core.info(`No runtime log artifact found for ${artifactName}`);
              core.setOutput('found', 'false');
              return;
            }
            const artifact = available[0];
            const response = await github.request('GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: artifact.id,
              archive_format: 'zip'
            });
            const fs = require('fs');
            const path = require('path');
            const zipPath = path.join(process.cwd(), 'tmp', 'runtime_log_download.zip');
            fs.mkdirSync(path.dirname(zipPath), { recursive: true });
            fs.writeFileSync(zipPath, Buffer.from(response.data));
            core.setOutput('found', 'true');
            core.setOutput('zip-path', zipPath);
            core.info(`Downloaded runtime artifact ${artifactName} (${artifact.id})`);

      - name: Extract runtime log artifact
        if: steps.download-runtime-log.outputs.found == 'true'
        run: |
          python3 - <<'PY'
          import zipfile
          from pathlib import Path

          zip_path = Path("${{ steps.download-runtime-log.outputs.zip-path }}")
          target_dir = Path("tmp/runtime_log_import")
          target_dir.mkdir(parents=True, exist_ok=True)
          with zipfile.ZipFile(zip_path) as zf:
            zf.extractall(target_dir)
          log_path = target_dir / "parallel_runtime_rspec.log"
          if not log_path.exists():
            raise SystemExit("parallel_runtime_rspec.log not found in artifact")
          log_path.replace(Path("log/parallel_runtime_rspec.log"))
          PY

      - name: Configure runtime grouping
        id: rspec-runtime-config
        run: |
          runtime_log="log/parallel_runtime_rspec.log"
          if [ -s "$runtime_log" ]; then
            echo "Using runtime log at $runtime_log"
            echo "PARALLEL_GROUP_BY=runtime" >> "$GITHUB_ENV"
            echo "PARALLEL_RUNTIME_LOG=$runtime_log" >> "$GITHUB_ENV"
          else
            echo "Runtime log missing or empty at $runtime_log; running without --group-by."
          fi

      - name: Run rspec
        run: make rspec
        env:
          PARALLEL_TEST_PROCESSORS: ${{ matrix.ci_node_total }}
          TEST_GROUP: ${{ matrix.ci_node_index }}
          YETI_DB_HOST: db
          YETI_DB_PORT: 5432
          CDR_DB_HOST: db
          CDR_DB_PORT: 5432
          CI: true

      - name: Check runtime log for cache
        if: always()
        id: rspec-runtime-save
        run: |
          runtime_log="log/parallel_runtime_rspec.log"
          if [ -s "$runtime_log" ]; then
            echo "save=true" >> "$GITHUB_OUTPUT"
          else
            echo "save=false" >> "$GITHUB_OUTPUT"
            echo "Runtime log missing or empty at $runtime_log; skipping cache save."
          fi

      - name: Upload rspec runtime log artifact
        if: always() && steps.rspec-runtime-save.outputs.save == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: rspec-runtime-log-${{ matrix.ci_node_index }}
          if-no-files-found: ignore
          path: log/parallel_runtime_rspec.log

      - name: Save artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rspec-artifacts-${{matrix.ci_node_index}}
          if-no-files-found: ignore
          include-hidden-files: true
          path: |
            tmp/capybara
            coverage


  rspec_ldap:
    name: Rspec tests for LDAP auth
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    services:
      db:
        image: ghcr.io/yeti-switch/yeti-web/pgsql:18

    needs: gems-caching
    strategy:
      fail-fast: false

    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}

      - name: Run rspec
        run: cp -v config/ldap.yml.distr config/ldap.yml && make rspec
        env:
          PARALLEL_TEST_PROCESSORS: 1
          TEST_GROUP: 0
          YETI_DB_HOST: db
          YETI_DB_PORT: 5432
          CDR_DB_HOST: db
          CDR_DB_PORT: 5432
          CI: true
          CI_RUN_LDAP: true

      - name: Save artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rspec-artifacts-ldap
          if-no-files-found: ignore
          include-hidden-files: true
          path: |
            tmp/capybara
            coverage


  rspec_runtime_cache:
    name: Save combined rspec runtime log cache
    runs-on: ubuntu-latest
    needs: rspec
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Download rspec runtime log artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: rspec-runtime-log-*
          path: tmp/runtime_logs
          if-no-files-found: ignore
          merge-multiple: false

      - name: Merge rspec runtime logs
        id: rspec-runtime-merge
        shell: bash
        run: |
          mkdir -p tmp
          runtime_log="log/parallel_runtime_rspec.log"
          mapfile -t runtime_logs < <(find tmp/runtime_logs -name 'parallel_runtime_rspec.log' -type f)
          if [ ${#runtime_logs[@]} -eq 0 ]; then
            echo "save=false" >> "$GITHUB_OUTPUT"
            echo "No runtime log artifacts found; skipping artifact upload."
            exit 0
          fi
          awk -F: '{ if ($2 + 0 > max[$1]) max[$1] = $2 } END { for (file in max) print file ":" max[file] }' "${runtime_logs[@]}" \
            | sort -t: -k2,2nr > "$runtime_log"
          if [ -s "$runtime_log" ]; then
            echo "save=true" >> "$GITHUB_OUTPUT"
          else
            echo "save=false" >> "$GITHUB_OUTPUT"
            echo "Merged runtime log is empty; skipping artifact upload."
          fi

      - name: Upload merged runtime log artifact
        if: steps.rspec-runtime-merge.outputs.save == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: runtime-log-${{ github.head_ref || github.ref_name }}
          if-no-files-found: error
          path: log/parallel_runtime_rspec.log



  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    container: ghcr.io/yeti-switch/yeti-web/build-image:trixie
    needs:
      - gems-caching
      - rspec
      - rspec_ldap
    steps:
      - uses: actions/checkout@v4
      - name: use cache
        uses: actions/cache@v4
        with:
          path: |
            vendor
            pgq-processors/vendor
            .bundle
            pgq-processors/.bundle
            /opt/yeti-web/vendor/rbenv
          key: gems-deb13-${{runner.os}}-${{hashFiles('Gemfile.lock')}}-${{hashFiles('pgq-processors/Gemfile.lock')}}-${{hashFiles('.ruby-version')}}
      - name: Download Coverage Outputs
        uses: actions/download-artifact@v4
        with:
          path: coverage

      - name: Merge Coverage results
        run: make coverage_report

      - name: Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: coverage/coverage.xml
          badge: true
          fail_below_min: true
          format: markdown
          hide_branch_rate: false
          hide_complexity: true
          indicators: true
          output: both
          thresholds: '60 80'

      - name: Adding coverage report to summary
        run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
#      - name: Add Coverage PR Comment
#        uses: marocchino/sticky-pull-request-comment@v2
#        if: github.event_name == 'pull_request'
#        with:
#          recreate: true
#          path: code-coverage-results.md
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
